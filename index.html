<html>
	<head>
		<title>Dilettante - Perl Builder</title>
	</head>
	<body>
		<h1>Perl Builder</h1>
		<h2>POD Documentation for all components of the builder</h2>
		<p><a href="podindex.html">POD is here</a></p>
		<h2>What is this</h2>
		<p>
			Dilettante Builder is essentially the Perl equivalent of Maven2. It is a script and a set of Perl modules which allows very large
			and complex software projects to be built in a controlled fashion with a minimum of additional effort and programmer time and
			resources. The builder fulfills several needs common to complex software projects:
		</p>
		<ul>
			<li>Build consistency - The Builder provides a carefully devised framework for building software which will provide consistent
			results for every developer.</li>
			<li>Sharing - Object code built by different developers or generated by a build management system is available to every developer
			within their environment automatically without extra work or error-prone manual processes.</li>
			<li>Simplicity - It is easy to do simple common tasks without needing to actually write any code using a simple configuration file
			which can be edited in any text editor and kept under revision control</li>
			<li>No need to know Perl - Since a large library of tasks already exists and more can be easily and quickly scripted by someone
			who has some Perl expertise most developers will only need to know what actions are available and how to configure them. They will
			not need to know how it works, it just works.</li>
			<li>Extensible - Additional actions can be added quickly and easily. Most common basic functions are either already built into
			Perl or are part of the core functionality of Dilettante. New actions extend the existing capabilities and are easy to reuse.</li>
		</ul>
		<h2>How does it compare with Maven2?</h2>
		<p>
			The most directly comparable OSS project available now is the Apache Maven2 Project. Dilettante aims squarely at filling the same
			need. There are two main differences between Dilettante and Maven2. Dilettante is a <b>lot</b> easier to use (well, we think so...).
			Extending Maven2 requires a considerable amount of effort. In order to be highly configurable and extensible Maven2 requires even
			the most trivial extension to provide a considerable amount of scaffolding in the form of XML configuration and/or annotation. With
			Dilettante the same things can usually be accomplished in 5 minutes with 5 or 10 lines of code. In 99% of the cases the
			desired functionality already exists and can be directly accessed. Maven2 plugins have no way to reuse or share code, and because of
			its rigid lifecycle design philosophy even if the desired functionality already exists in another plugin it is virtually impossible
			to reuse it in another context.
		</p>
		<p>
			In many ways Dilettante parallels Maven2. The Maven team spent a lot of time and energy considering the requirements for a modern
			build system. Their approach to distributing object code and emphasis on consistency across the entire project are good things.
			Unfortunately Java is a very cumbersome language to use for build tools. A build tool above all requires a lot of flexibility and
			at the same time consistency. Thus Dilettante steals concepts like local and group level binary repositories unabashedly from
			Maven2. On the other hand Dilettante does not impose any rigid preconceived idea of a build lifecycle. It also does not rely on
			large and complex XML configuration files. XML is all well and good, but builds change constantly and XML is at best difficult to
			edit by hand and the resulting files are hard to decipher. Instead Dilettante relies on old-fashioned properties file syntax, which
			is easier to edit, a lot more compact, more human readable, and less error prone.
		</p>
		<p>
			Dilettante was developed over the last couple of years to manage several large complex J2EE product build environments. Our experience
			with both tools has shown that we have experienced an overall 400% reduction in time required for build maintanence compared to 
			using Maven2 on some of the same projects, and we no longer use any other tool in this category.
		</p>
		<h2>Limitations</h2>
		<p>
			There are 2 main existing limitations to the Builder. First of all it is not <b>entirely</b> cross-platform. All of the modules
			themselves will function on both Linux and MS OSes and should work fine on other *nix (and OS-X). However there are simply a LOT of
			things one might like to accomplish during more complex phases of a build which are very hard to accomplish on non-Unix type
			platforms. For example as far as we have been able to determine there is simply no way on a MS platform to start up a "background"
			process and continue a build! This is not really a limitation of the builder itself, but more a limitation of the environment
			which would need to be addressed by a team implementing a build process.
		<p>
		<p>
			The builder doesn't provide the same level of access to non-filesystem resources as Maven2's 'wagon'. There are a couple of
			answers to this. First of all we rely extensively on the CPAN IO::All module, which in theory <b>does</b> provide the ability to
			do things like treat a URL, an SSH server, or an FTP site like a local file system. In our experience this functionality doesn't
			work. Assuming at some point that IO::All actually gets fixed then most of these features should be available to Dilettante. In any
			case our experience with Wagon is that most of these capabilities are more theoretical than practical anyway. In a realistic
			commercial environment external tools will be required to mirror offsite repositories and ad-hoc access to resources not under the
			control of the build team is very rarely acceptable anyway. Existing applications can perform any other remaining tasks, or 
			else the same things can be accomplished via networked file systems, etc. In any case adding such capabilities to Dilettante is
			hardly an onerous task.
		</p>
		<h2>Comparison with other tools</h2>
		<p>
			There are many other build tools in the world. Some of them address different issues than Dilettante and others overlap with it
			to some extent. Dilettante in general can live happily with and be integrated with these tools to extend and enhance an existing
			build system.
		</p>
		<h3>Make</h3>
		<p>
			Make, in its various flavors, is a good tool for compiling things. However make has a number of weaknesses and doesn't really
			address other aspects of development particularly well. For one thing make is fairly C/C++ centered. In principle it is not
			hard to use it for other things, but as soon as you attempt to say compile Java with it, it quickly becomes very difficult to
			make things work well. A multitude of special cases arise and a lot of make's power derives from the fact that it <b>knows</b>
			certain things about how compile C code. It also relies in subtle ways on tools conforming to certain unwritten conventions.
			Make files are almost impossible to debug and complex projects will virtually require a dedicated 'make guru' in order to
			accomplish things. Finally make by virtue of its design simply does not easily facilitate consistency. It is almost impossible
			to be sure that the same make script will do the same thing on any 2 systems with any degree of certainty.
		</p>
		<h3>Autoconf</h3>
		<p>
			GNU Autoconf addresses a set of issues which are not really all that germane to the problem set Dilettante is meant to
			address. Autoconf is mainly intended to facilitate compilation of C/C++ code on end user systems with make. It isn't designed
			to address issues like distributing binaries to a team. Dilettante could be used to create source packages which compile with
			autoconf.
		</p>
		<h3>Integration Systems</h3>
		<p>
			Build/Integration management systems. There are a lot of build management systems out there now. Mostly they are designed to 
			supplement tools like Maven2. Generally you still need a tool like the builder to do the actual low level tasks of compiling
			and generating output for reports, etc. Some of them can be integrated with command line tools, in which case they can be
			leveraged to do things Dilettante doesn't do.
		</p>
		<h1>Builder Concepts</h1>
		<p>
			One of the aims of Dilettante is to provide a consistent conceptual framework upon which to base a complex build system. By
			organizing builds in a consistent way across the whole development environment problems can be avoided and common approaches
			to tasks can be re-applied in different situations.
		</p>
		<h2>Process</h2>
		<p>
			The process is the overall structuring of engineering activities to achieve the end result. Certain distinct tasks must be
			accomplished during the process, such as design, coding, unit test, integration, quality control testing, revision control,
			and building deliverable software. Dilettante is simply a tool which participates in the process and makes certain parts of
			it easier or at least possible.
		</p>
		<h2>Product</h2>
		<p>
			The most basic unit of organization is the product. A build/software engineering process has as its goal some form of product. The
			product is the primary goal of the process and delivering the product in its final form is the underlying reason for all other
			process activities. Dilettante builds components of the product and automates product build, test, and packaging activities.
		</p>
		<h2>Build</h2>
		<p>
			A build is some specific automated activity or set of activities which produces outputs which are then incorporated into other
			parts of the process, usually as all or part of the deliverable product. Specifically a build is accomplished by invoking the
			build.pl script to process a build.properties file. Usually a complex product will consist of several, possibly many, builds
			which together generate artifacts which make up the product. Often these will be organized in a hierarchy so that 'master'
			builds are used to generate all or large parts of a product by carrying out a number of lower level sub builds which create
			individual components.
		</p>
		<h2>Module</h2>
		<p>
			A module is a conceptual component of a software product which provides some specific functionality. It might also be a set of
			actions which are taken together in a consistent fashion to perform a specific task, like perform certain integration tests. A
			module will generally contain source code, unit tests, and other resources plus a build.properties file which specifies the
			required steps to produce a software component or accomplish a specific activity.
		</p>
		<p>
			Although there is no specific limit to the scope of a particular module in the context of engineering a product it is a very
			good idea to limit the scope of a particular module to one specific task. For instance compiling a specific unit of code and
			creating a library from it, and unit testing that code is a good example of what a module should do. Usually a module
			corresponds to a particular build and has one build.properties file.
		</p>
		<p>
			Modules are usually organized according to a consistent template. While nothing mandates this it is much easier to maintain
			a large project in which all the modules conform to a standardized format. Dilettante simply provides a set of default values
			for a wide variety of properties which control where the parts of a module are found and where all the generated output of a
			build goes. These can be modified as required in specific instances and/or a different set of defaults provided. Generally the
			builder uses defaults similar to those chosen by Maven2 on the theory that reinventing the wheel is a waste of time and many
			developers will already have a good grasp of that structure.
		</p>
		<h2>Build File</h2>
		<p>
			A build file is a properties file, usually named 'build.properties', which contains all the information required to execute a
			single build. Thus it should be possible to determine exactly what a build does by examining this one file, although common
			values will often be acquired from other properties files in order to avoid duplication of information. So for example a database
			password used in a number of module builds would likely be stored in a single place and then usually substituted into specific
			properties in the individual build or into output files.
		</p>
		<h2>Artifacts</h2>
		<p>
			An artifact is an output of a build which is intended to be shared and incorporated into other components of a product. Usually
			each module results in the production of one artifact, plus possibly some additional ancillary artifacts which may be used with
			it at other points in the build process. Each artifact is a file. Artifacts may be shared between builds and between different
			developers by installation or deployment in a repository.
		</p>
		<p>
			Every artifact is identified by a set of attributes. These are its group, its artifactid, its version, and its type. The
			group attribute is a name space in which a particular provider can use its artifact ids without worrying about id collisions.
			Usually a team, product, or organization will put all of its artifacts in one or possibly several groups. The artifactid is
			unique within a group and identifies the particular file. The type additionally gives the build system a way to identify the
			format of the artifact in order to decide what its use is and what tools can handle it. The version specifies the particular
			revision of an artifact for dependency management purposes. Every version is a unique instance of the artifact which can be
			resolved in a repository.
		</p>
		<h2>Repositories</h2>
		<p>
			Some mechanism needs to exist which allows multiple members of a development team to access each other's work. Version control
			systems provide this capability for source code, but often it is necessary or desirable to also share <b>object</b> code between
			developers. This is accomplished by use of repositories. A repository is a directory with a specific structure which
			Dilettante can traverse in order to recover artifacts. Dilettante utilizes two repositories in order to control the flow of
			artifact distribution in the overall build process.
		</p>
		<p>
			Local repository - Each developer has an individual local repository. This is usually stored on the developer's individual
			system. Each local repository belongs to that specific developer (or pair etc.). Install actions are used to move artifacts from
			wherever they are generated into the local repository. Other builds can then recover these local copies in order to link against
			them, etc. In this way a developer can have an individual set of binaries built from source code on the local machine which are
			used to link and test against.
		</p>
		<p>
			Group repository - A development team has a group repository which will contain validated artifacts. These will be accessed by
			all developers in the team. Once a developer has validated a particular artifact (IE the library has passed all tests) then a
			deployment action can be used to post it to the group repository, which is stored on a file system accessible to the entire
			team (IE an NFS share or something similar).
		</p>
		<p>
			Dilletante's dependency resolution module preferentially acquires artifacts from the group repository, using local copies only
			if they are newer. Thus once an artifact is deployed the entire team will automatically build against that new artifact until
			and unless the developer produces a newer version and installs it locally. This allows everyone in the team to work with their
			own copies of things which are either known to work or are updated versions not yet deployed and interim experimental unverified
			updates to things will not break anyone else's code until it has been confirmed that everything will work together.
		</p>
		<h2>Dependencies</h2>
		<p>
			Modules generally depend on components of other modules. A build.properties file will specify the artifacts which are required
			for a given module to build, its dependencies. Every dependency is an artifact. Dependencies are always resolved to either the
			local or group repository as described above. In order to simplify the build environment Dilettante has certain capabilities
			related to dependencies.
		</p>
		<p>
			Individual dependencies are spelled out for each module in its build.properties file using the build.dependency attribute. As
			many dependencies as necessary may be present in this property. All of them will be identified and recovered from one of the
			repositories as required by the build. This is accomplished by the dependency step, which is the default action of the 
			Dependencies module. Each build.dependency value specifies the group, artifactid, version, and type of an artifact which
			is depended on.
		</p>
		<p>
			First of all whenever Dilettante generates an artifact, it also generates a '.dependencies' file to go with it and install or
			deploy actions will copy this file to the repository along with the artifact file itself. This file will list all of the
			artifacts this particular artifact lists as dependencies. This allows for complex dependency management.
		</p>
		<p>
			Dependencies may be <b>transitive</b>. That is it is not necessary for a module to specify sub dependencies explicitly. If
			A depends on B which depends on C then A only needs to specify one dependency, B. Dilettante will determine for itself that
			B depends on C and resolve it as required. This greatly reduces configuration and eliminates a lot of potential consistency
			errors.
		</p>
		<p>
			Dependencies also have a scope. This is used to determine when a given dependency is or is not required. Arbitrary scopes may
			be defined, but Dilettante understands three in particular, compile, test, and provided. Compile dependencies are ones which
			are required at both compilation time and run time. Test dependencies are required during unit testing, and provided dependencies 
			are required only during compilation (they are always available in the run time environment of the target system).
		</p>
		<p>
			In order to improve manageability of build scripts the versions of dependencies may be specified in a build.dependency.managed 
			attribute in a build.properties file. This file can then be included in all other build.properties files, which can then simply
			leave the version field empty. This way if an artifact is used in many places its version (which is likely to change) can be
			in one single location.
		</p>
		<h1>Putting things together</h1>
		<p>
			Taken together these Dilettante capabilities facilitate creating a smoothly working build process. Many possible structures for
			the build process are possible, however in general the most straightforward and flexible type of structure would be something
			like the following.
		</p>
		<p>
			A product build might consist of for example 4 modules, A, B, C, and D. Modules A, B, and C would each contain source code, and unit
			test code. C might be the most basic and depend on nothing else. Its build would compile it, compile and execute tests, and install
			the resulting object code file if the tests pass. A and B can then both specify C as a dependency and contain code which links with
			C, and more unit test code for their own functions. Their builds would function in the same way as C. The D module can then depend
			on A and B (and implicitely on C). D would contain only integration tests. 
		</p>
		<p>
			A developer can now check C out of version control and work on it, calling build.pl to compile and test it until whatever changes 
			were made pass unit tests, at which point it will install in the developer's local repository. A and B can now also be checked out, 
			and when they are built they will utilize the local copy of C to link against. Once they pass their unit tests they will also
			deploy to the local repository. Finally D can be checked out and integration tests run. D would contain instructions to allow it
			to run the C, B, and A builds as sub builds. Once all tests pass all the code can be committed back to version control and finally
			a build can be performed on the group's integration system, followed by a deploy. The updated artifacts will now be available in
			the group repository and any other developers builds will automatically use them. At any point in the process version control
			can be used to resolve any conflicts between developers, and if the integration system fails to build the new set of modules
			version control can be used to roll the changes back and things should revert back to their previous state as soon as another
			build/deploy is run.
		</p>
		<p>
			Furthermore a developer can update the version of a module on his system and even after deployment of the new version anyone
			else still using the previous build.properties to resolve dependencies will never even see the new version at all, even after it
			is deployed, unless they choose to update. Different development branches can exist in any desired fashion which share more or
			less code at the module level and any set of code can be tested and deployed and managed on its own branch as desired.
		</p>
		<p>
			Finally the D build.properties can also specify actions to do additional things like update the team's collaboration server,
			post new versions of javaDocs, test reports, etc. All these actions can follow after deploy in D and thus will only happen
			once D and all its dependencies work properly together.
		</p>
		<h1>More sophistication</h1>
		<p>
			<em>Many</em> additional features can be added to the build system simply by leveraging the inherent capabilities of the build.pl
			script. For example common sets of Macros can be defined and property value substitutions used to create standardized sets of
			steps which particular artifact types use, essentially the Maven2 lifecycle concept without being confined absolutely within its
			predefined lifecycle definitions. The Builder.pm module can also be wrapped in other more specialized scripts in order to reuse
			its functionality for specialized purposes. By calling external programs, which is very easy in Perl, it is possible to make
			builds which do virtually any task, even system management tasks.
		</p>
	</body>
</html>